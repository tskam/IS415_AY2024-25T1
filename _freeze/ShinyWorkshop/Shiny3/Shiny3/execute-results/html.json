{
  "hash": "7b57402a76545d9e03ec4e5bbdd09bbe",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Building Web-enabled Geospatial Analytics Application with Shiny: Beyond the basic\"\nsubtitle: \"\"  \nauthor: \"Dr. Kam Tin Seong<br/>Assoc. Professor of Information Systems\"\ninstitute: \"School of Computing and Information Systems,<br/>Singapore Management University\"\ndate: \"2024-07-28\"\nformat: \n  revealjs:\n    width: 1600\n    height: 900\n    show-notes: false\n    slide-number: true\n    show-slide-number: 'all'\ndate-format: \"DD MMM YYYY\"\nexecute: \n  freeze: true\neditor: visual\n---\n\n\n\n## Overview\n\nIn this lesson, selected advanced methods of Shiny will be discussed. You will also gain hands-on experiences on using these advanced methods to build Shiny applications.\n\nBy the end of this lesson, you will be able to:\n\n-   understanding the basic development cycle of creating apps, making changes, and experimenting with the results,\n-   debug errors in the codes,\n-   build complex Shiny application using module, and\n-   improve the productivity of Shiny applications development\n\n## Working with Shiny Layout\n\nShiny includes a number of facilities for laying out the components of an application. This guide describes the following application layout features:\n\n-   A `sidebarLayout()`: for placing a `sidebarPanel()` of inputs alongside a `mainPanel()` output content.\n\n-   Custom layouts using Shiny's grid layout system (i.e., `fluidRow()` & `column()`).\n\n-   Segmenting layouts using the `tabsetPanel()` and `navlistPanel()` functions.\n\n-   Creating applications with multiple top-level components using the `navbarPage()` function.\n\n------------------------------------------------------------------------\n\n### Customising layout with `fluidRow()` and `column()`\n\nIn this hands-on exercise, you will learn how to rearrange the drill-down bar chart view so that both the Race and Gender bar charts will be placed next to each other as shown in the figure below.\n\n![](img/image12.jpg)\n\n------------------------------------------------------------------------\n\n### Customising layout with `fluidRow()` and `column()`\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- fluidPage(\n  titlePanel(\"Dual Plots Drill-down Bar Chart\"),\n  mainPanel(\n    fluidRow(\n      column(6,\n             plotlyOutput(\n               outputId=\"race\", \n               width=\"300px\",\n               height=\"300px\")),  \n      column(6,\n             plotlyOutput(\n               outputId=\"gender\", \n               width=\"300px\",\n               height=\"300px\"))\n    )\n  )\n)\n```\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\nWhat can you learn from the code chunk on the left?\n\n-   The first argument of the column function is width, which is based on the Bootstrap 12-wide grid system, so the total width for each row should add up to **12**.\n-   Shiny has numerous \"Panel\" functions, which you can think as the elements you put inside the layout containers you created using the \"Layout\" functions like `sidebarLayout()`, `fluidrow()`, `column()`, etc.\n:::\n:::\n\n------------------------------------------------------------------------\n\n### Customising Multi-row layout with `fluidRow()` and `column()`\n\n::: columns\n::: {.column width=\"50%\"}\n`sidebarLayout()` is built on top of a flexible multi-row layout, which you can use directly to create more visually complex apps.\n\n![](img/image13.jpg)\n:::\n\n::: {.column width=\"50%\"}\nAs usual, you start with `fluidPage()`. Then you create rows with `fluidRow()`, and columns with `column()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfluidPage(\n  fluidRow(\n    column(4, \n      ...\n    ),\n    column(8, \n      ...\n    )\n  ),\n  fluidRow(\n    column(6, \n      ...\n    ),\n    column(6, \n      ...\n    )\n  )\n)\n```\n:::\n\n\n:::\n:::\n\n------------------------------------------------------------------------\n\n## Multi-page layouts\n\n::: columns\n::: {.column width=\"50%\"}\nShiny provides several functions for building multi-page layout, they are:\n\n-   tabsetPanel() + tabPanel()\n\n-   navlistPanel() + tabPanel()\n\n-   navbarMenu() + tabPanel()\n:::\n:::\n\n------------------------------------------------------------------------\n\n### tabsetPanel() and tabPanel()\n\n::: {style=\"font-size: 0.9em\"}\n::: columns\n::: {.column width=\"60%\"}\nThe simple way to break up a page into pieces is to use [`tabsetPanel()`](https://shiny.rstudio.com/reference/shiny/1.7.0/tabsetPanel.html) and its close friend [`tabPanel()`](https://shiny.rstudio.com/reference/shiny/1.7.0/tabPanel.html).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- fluidPage(\n  titlePanel(\"Multi-pages Layout\"),\n  tabsetPanel(\n    tabPanel(\"Import data\", \n             fileInput(\"file\", \"Data\", buttonLabel = \"Upload...\"),\n             textInput(\"delim\", \"Delimiter (leave blank to guess)\", \"\"),\n             numericInput(\"skip\", \"Rows to skip\", 0, min = 0),\n             numericInput(\"rows\", \"Rows to preview\", 10, min = 1)\n    ),\n    tabPanel(\"Variable selection\"),\n    tabPanel(\"Model calibration\"),\n    tabPanel(\"Model evaluation\")\n  )\n)\n```\n:::\n\n\n:::\n\n::: {.column width=\"40%\"}\nFigure below shows the multi-page layouts created using the code chunk on the left.\n\n![](img/image14.jpg)\n\n::: callout-note\n`tabsetPanel()` can be used anywhere in your app; it's totally fine to nest tabsets inside of other components (including tabsets!) if needed.\n:::\n:::\n:::\n:::\n\n------------------------------------------------------------------------\n\n### navlistPanel() and tabPanel()\n\n::: columns\n::: {.column width=\"55%\"}\n-   [`navlistPanel()`](https://shiny.rstudio.com/reference/shiny/1.7.0/navlistPanel.html) is similar to `tabsetPanel()` but instead of running the tab titles horizontally, it shows them vertically in a sidebar.\n-   It also allows you to add headings with plain strings.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- fluidPage(\n  navlistPanel(\n    id = \"tabset\",\n    \"Data Preparation\",\n    tabPanel(\"Data Import\", \n             \"View table\"),\n    tabPanel(\"Data transformation\", \n             \"Output table\"),\n    \"IDEA\",\n    tabPanel(\"Univariate analysis\", \n             \"Distribution plot\"),\n    tabPanel(\"Bivariate analysis\", \n             \"Correlation matrix\")\n  )\n)\n```\n:::\n\n\n:::\n\n::: {.column width=\"45%\"}\n![](img/image15.jpg)\n:::\n:::\n\n------------------------------------------------------------------------\n\n### `navbarMenu()` and `tabPanel()`\n\n::: columns\n::: {.column width=\"55%\"}\nAnother approach is use [`navbarPage()`](https://shiny.rstudio.com/reference/shiny/1.7.0/navbarPage.html): it still runs the tab titles horizontally, but you can use `navbarMenu()` to add drop-down menus for an additional level of hierarchy.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- navbarPage(\n  \"Welcome to TimeVA\",\n  tabPanel(\"Data Import\", \"one\"),\n  navbarMenu(\"IDEA\", \n             tabPanel(\"Time-series line graph\", \"L graph\"),\n             tabPanel(\"Horizon graph\", \"H graph\")\n             ),\n  tabPanel(\"Time-series Analysis\", \"TSA\"),\n  navbarMenu(\"Time-series forecasting\", \n             tabPanel(\"Exponential Smoothing\", \"ES\"),\n             tabPanel(\"ARIMA\", \"ARIMA\"),\n             tabPanel(\"Automatic\", \"auto\")\n  )\n)\n```\n:::\n\n\n:::\n\n::: {.column width=\"45%\"}\n![](img/image16.jpg)\n:::\n:::\n\n## Shiny Themes\n\n::: columns\n::: {.column width=\"50%\"}\n::: {style=\"font-size: 0.9em\"}\n-   Shiny v1.6 and higher integrates with the [**bslib**](https://rstudio.github.io/bslib/) package providing easy access to modern versions of [Bootstrap](https://getbootstrap.com/), [Bootswatch](https://bootswatch.com/) themes, as well as custom themes that can even be modified in real time!\n-   To use **bslib** in your own Shiny app, pass a [`bs_theme()`](https://rstudio.github.io/bslib/reference/bs_theme.html) object to the theme argument of the relevant page layout function, such as `navbarPage()` or `fluidPage()`.\n-   Inside `bs_theme()`, you can specify a version of Bootstrap and (optionally) a Bootswatch theme (e.g. cyborg)\n:::\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"3,6\"}\nlibrary(shiny)\nlibrary(tidyverse)\nlibrary(bslib)     \nexam <- read_csv(\"data/Exam_data.csv\")\nui <- fluidPage(\n  theme = bs_theme(bootswatch = \"cyborg\"), \n  titlePanel(\"Pupils Examination Results Dashboard\"),\n```\n:::\n\n\n\n![](img/image17.jpg)\n:::\n:::\n\n------------------------------------------------------------------------\n\n### Customising themes\n\n::: columns\n::: {.column width=\"50%\"}\n[`bs_theme()`](https://rstudio.github.io/bslib/reference/bs_theme.html) provides direct access to Bootstrap's main colors & fonts as well as any of the 100s of more specific theming options. Also, when it comes to custom font(s) that may not be available on the end users machine, make sure to leverage {bslib}'s helper functions like [`font_google()`](https://fonts.google.com/), `font_link()`, and `font_face()`, which assist in including font file(s) in an convenient, efficient, and responsible way.\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"8,9,10,11,12\"}\nlibrary(shiny)\nlibrary(tidyverse)\nlibrary(bslib)\n\nexam <- read_csv(\"data/Exam_data.csv\")\n\nui <- fluidPage(\n  theme = bs_theme(bg = \"#0b3d91\", \n                   fg = \"white\",   \n                   primary = \"#FCC780\", \n                   base_font = font_google(\"Roboto\"),  \n                   code_font = font_google(\"Roboto\")), \n  titlePanel(\"Pupils Examination Results Dashboard\"),\n```\n:::\n\n\n:::\n:::\n\n------------------------------------------------------------------------\n\n### Customising Plot\n\n::: columns\n::: {.column width=\"50%\"}\nWhile a lot of custom theming can be done via `bs_theme()` (i.e., CSS), it fundamentally can't effect `renderPlot()`, because the image is rendered by R, not by the web browser. To help solve this problem, [thematic](https://rstudio.github.io/thematic/) package can be used to translate CSS to new R plotting defaults by just calling `thematic::thematic_shiny()` before running an app.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"5\"}\nlibrary(shiny)\nlibrary(tidyverse)\nlibrary(bslib)\n\nthematic::thematic_shiny()\n\nexam <- read_csv(\"data/Exam_data.csv\")\n```\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n![](img/image18.jpg)\n:::\n:::\n\n## Introducing Shiny Module\n\n-   As Shiny applications grow larger and more complicated, modules are used to manage the growing complexity of Shiny application code.\n\n-   Functions are the fundamental unit of abstraction in R, and we designed Shiny to work with them.\n\n-   We can write UI-generating functions and call them from our app, and we can write functions to be used in the server function that define outputs and create reactive expressions.\n\n------------------------------------------------------------------------\n\n### Shiny Modules Workflow\n\n::: columns\n::: {.column width=\"50%\"}\nAn example of a large and complex Shiny application diagram.\n\n![](img/image5.jpg)\n:::\n\n::: {.column width=\"50%\"}\nAn example of modulerised Shiny application.\n\n![](img/image6.jpg)\n:::\n:::\n\n------------------------------------------------------------------------\n\n### Module basics\n\nA module is very similar to an app. Like an app, it's composed of two pieces:\n\n-   The **module UI** function that generates the *ui* specification.\n\n-   The **module server** function that runs code inside the *server* function.\n\nThe two functions have standard forms. They both take an *id* argument and use it to namespace the module. To create a module, we need to extract code out of the app UI and server and put it in to the module UI and server.\n\n------------------------------------------------------------------------\n\n### In-class Exercise: Building Shiny App with Basic Modele\n\nIn order to understand the basics of Shiny modules, let us consider a simple Shiny application codes to plot a histogram shown below.\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- fluidPage(\n  selectInput(\"var\", \n              \"Variable\", \n              names(mtcars)),\n  numericInput(\"bins\", \n               \"bins\", \n               10, \n               min = 1),\n  plotOutput(\"hist\")\n)\nserver <- function(input, \n                   output, \n                   session) {\n  data <- reactive(mtcars[[input$var]])\n  output$hist <- renderPlot({\n    hist(data(), \n         breaks = input$bins, \n         main = input$var)\n  }, res = 96)\n}\n```\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n![](img/image7.jpg)\n:::\n:::\n\n------------------------------------------------------------------------\n\n### Module UI\n\nWe'll start with the module UI. There are two steps:\n\n-   Put the UI code inside a function that has an id argument.\n\n-   Wrap each existing ID in a call to NS(), so that (e.g.) \"var\" turns into NS(id, \"var\").\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhistogramUI <- function(id) {\n  tagList(\n    selectInput(NS(id, \"var\"), \"Variable\", choices = names(mtcars)),\n    numericInput(NS(id, \"bins\"), \"bins\", value = 10, min = 1),\n    plotOutput(NS(id, \"hist\"))\n  )\n}\n```\n:::\n\n\n\n-   Here we have returned the UI components in a `tagList()`, which is a special type of layout function that allows you to bundle together multiple components without actually implying how they will be laid out.\n-   It is the responsibility of the person calling `histogramUI()` to wrap the result in a layout function like `column()` or `fluidRow()` according to their needs.\n\n------------------------------------------------------------------------\n\n### Module server\n\nNext we tackle the server function. This gets wrapped inside another function which must have an id argument. This function calls `moduleServer()` with the *id*, and a function that looks like a regular server function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhistogramServer <- function(id) {\n  moduleServer(id, function(input, output, session) {\n    data <- reactive(mtcars[[input$var]])\n    output$hist <- renderPlot({\n      hist(data(), breaks = input$bins, main = input$var)\n    }, res = 96)\n  })\n}\n```\n:::\n\n\n\n::: callout-note\n-   `moduleServer()` takes care of the namespacing automatically: inside of `moduleServer(id)`,\n-   *input*$var* and *input$bins refer to the inputs with names *NS(id, \"var\")* and *NS(id, \"bins\")*.\n:::\n\n------------------------------------------------------------------------\n\n### Revised Shiny Application\n\nNow that we have the ui and server functions, it's good practice to write a function that uses them to generate an app which we can use for experimentation and testing:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- fluidPage(\n    histogramUI(\"hist\")\n    )\n\nserver <- function(input, output, session) {\n    histogramServer(\"hist\")\n    }\n\nshinyApp(ui, server)\n```\n:::\n\n\n\n::: callout-note\nLike all Shiny control, you need to use the same *id* in both UI and server, otherwise the two pieces will not be connected.\n:::\n\n------------------------------------------------------------------------\n\n### In-class Exercise: Function to import csv file\n\n![](img/image8.jpg)\n\n------------------------------------------------------------------------\n\n### Module UI function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Module UI function\ncsvFileUI <- function(id, label = \"CSV file\") {\n    # `NS(id)` returns a namespace function, which was save as `ns` and will\n    # invoke later.\n    ns <- NS(id)\n    \n    tagList(\n        fileInput(ns(\"file\"), label),\n        checkboxInput(ns(\"heading\"), \"Has heading\"),\n        selectInput(ns(\"quote\"), \"Quote\", c(\n            \"None\" = \"\",\n            \"Double quote\" = \"\\\"\",\n            \"Single quote\" = \"'\"\n        ))\n    )\n}\n```\n:::\n\n\n\n------------------------------------------------------------------------\n\n### Module server function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncsvFileServer <- function(id, stringsAsFactors) {\n    moduleServer(\n        id,\n        function(input, output, session) {\n            userFile <- reactive({\n                validate(need(input$file, message = FALSE))\n                input$file\n            })\n            dataframe <- reactive({\n                read.csv(userFile()$datapath,\n                         header = input$heading,\n                         quote = input$quote,\n                         stringsAsFactors = stringsAsFactors)\n            })\n            observe({\n                msg <- sprintf(\"File %s was uploaded\", userFile()$name)\n                cat(msg, \"\\n\")\n            })\n            return(dataframe)\n        }\n    )    \n}\n```\n:::\n\n\n\n------------------------------------------------------------------------\n\n### The Shiny app\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- fluidPage(\n    sidebarLayout(\n        sidebarPanel(\n            csvFileUI(\"datafile\", \"User data (.csv format)\")\n        ),\n        mainPanel(\n            dataTableOutput(\"table\")\n        )\n    )\n)\n\nserver <- function(input, output, session) {\n    datafile <- csvFileServer(\"datafile\", stringsAsFactors = FALSE)\n    \n    output$table <- renderDataTable({\n        datafile()\n    })\n}\n\nshinyApp(ui, server)\n```\n:::\n\n\n\n## Debugging\n\n::: {style=\"font-size: 0.9em\"}\n::: columns\n::: {.column width=\"50%\"}\n### Programming == Frustration?\n\n![](img/image2.jpg)\n\nSource: The original [article](https://medium.com/@JustineBethKay/programming-is-frustration-788cfe9d73c7).\n:::\n\n::: {.column width=\"50%\"}\nThree main cases of problems which we'll discuss below:\n\n-   You get an unexpected error. This is the easiest case, because you'll get a traceback which allows you to figure out exactly where the error occurred.\n-   You don't get any errors, but some value is incorrect. Here, you'll need to use the interactive debugger, along with your investigative skills to track down the root cause.\n-   All the values are correct, but they're not updated when you expect. This is the most challenging problem because it's unique to Shiny, so you can't take advantage of your existing R debugging skills.\n:::\n:::\n:::\n\n------------------------------------------------------------------------\n\n### Common errors\n\n#### \"Object of type 'closure' is not subsettable\"\n\n-   You forgot to use () when retrieving a value from a reactive expression *plot(userData)* should be *plot(userData())*\n\n------------------------------------------------------------------------\n\n### Common errors\n\n#### \"Unexpected symbol\n\n#### \"Argument xxx is missing, with no default\"\n\n-   Missing or extra comma in UI.\n-   Sometimes Shiny will realise this and give you a hint, or use RStudio editor margin diagnostics.\n\n------------------------------------------------------------------------\n\n### Common errors\n\n#### \"Operation not allowed without an active reactive context. (You tried to do something that can only be done from inside a reactive expression or observer.)\n\n-   Tried to access an input or reactive expression from directly inside the server function. You must use a reactive expression or observer instead.\n-   Or if you really only care about the value of that input at the time that the session starts, then use isolate().\n\n------------------------------------------------------------------------\n\n## Standard R debugging tools\n\n-   Tracing\n    -   tracebacks\n    -   print()/cat()/str()\n    -   renderPrint eats messages, must use cat(file = stderr(), \"\"...)\n    -   Also consider shinyjs package's logjs, which puts messages in the browser's JavaScript console\\\n-   Debugger\n    -   Set breakpoints in RStudio\n    -   browser()\n    -   Conditionals: if (!is.null(input\\$x)) browser()\n\n------------------------------------------------------------------------\n\n### In-class Exercise: Working with Traceback in Shiny\n\nIn this hands-on exercise, you will learn how to detect error by using traceback in Shiny.\n\n::: columns\n::: {.column width=\"50%\"}\nThe codes:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nf <- function(x) g(x)\ng <- function(x) h(x)\nh <- function(x) x * 2\n\nui <- fluidPage(\n    selectInput(\"n\", \"N\", 1:10),\n    plotOutput(\"plot\")\n)\nserver <- function(input, output, session) {\n    output$plot <- renderPlot({\n        n <- f(input$n)\n        plot(head(cars, n))\n    }, res = 96)\n}\nshinyApp(ui, server)\n```\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\nOp, there is an error!\n\n![](img/image3.jpg)\n:::\n:::\n\n------------------------------------------------------------------------\n\n### Learning how to debug: Traceback in Shiny\n\n::: columns\n::: {.column width=\"50%\"}\n::: {style=\"font-size: 0.75em\"}\n![](img/image4.jpg) Things to learn from the call stack:\n\n-   The first few calls start the app in this case you just see runApp() but depending on how you start the app, you might see something more complicated.\n-   In general, you can ignore anything before the first runApp(); this is just the setup code to get the app running.\n:::\n:::\n\n::: {.column width=\"50%\"}\n::: {style=\"font-size: 0.75em\"}\n-   Next, you'll see some internal Shiny code in charge of calling the reactive expression:\n    -   Here, spotting **output\\$plot** is really important --- that tells which of your **reactives (plot)** is causing the error. The next few functions are internal, and you can ignore them.\n-   Finally, at the very top, you'll see the code that you have written:\n    -   This is the code called inside of *renderPlot()*. You can tell you should pay attention here because of the file path and line number; this lets you know that it's your code.\n:::\n\n::: callout-tip\nIf you get an error in your app but don't see a traceback then make sure that you're running the app using Cmd/Ctrl + Shift + Enter (or if not in RStudio, calling runApp()), and that you've saved the file that you're running it from. Other ways of running the app don't always capture the information necessary to make a traceback.\n:::\n:::\n:::\n\n------------------------------------------------------------------------\n\n## In-class Exercise: Working with RStudio's Interactive Debugger\n\n::: columns\n::: {.column width=\"50%\"}\nIn this hands-on Exercise, you will learn how to work with the interactive debugger in RStudio.\n\n-   Double click prototype7a.\n-   Double click on *prototype7a.rproj* file to open the project file in RStudio.\n-   Click on *app.R* file to open the Shiny app file on RStudio\n-   Add a call to *browser()* in your source code (for example line 5).\n-   Click in **Run App** button to run the Shiny app.\n:::\n\n::: {.column width=\"50%\"}\n![](img/image4a.jpg)\n\n-   Next (press n): executes the next step in the function. Note that if you have a variable named n, you'll need to use print(n) to display its value.\n-   Continue (press c): leaves interactive debugging and continues regular execution of the function. This is useful if you've fixed the bad state and want to check that the function proceeds correctly.\n-   Stop (press Q): stops debugging, terminates the function, and returns to the global workspace. Use this once you've figured out where the problem is, and you're ready to fix it and reload the code.\n:::\n:::\n\n## Shinytest\n\n-   [Shinytest](https://rstudio.github.io/shinytest/index.html) uses snapshot-based testing strategy.\n-   The first time it runs a set of tests for an application, it performs some scripted interactions with the app and takes one or more snapshots of the application's state.\n-   These snapshots are saved to disk so that future runs of the tests can compare their results to them.\n\n------------------------------------------------------------------------\n\n### Testing\n\n-   There are many possible reasons for an application to stop working. These reasons include:\n    -   An upgraded R package has different behavior. (This could include Shiny itself!)\n    -   You make modifications to your application.\n    -   An external data source stops working, or returns data in a changed format.\n-   Automated tests can alert you to these kinds of problems quickly and with almost zero effort, after the tests have been created.\n\n## References\n\n### Shiny Layout\n\n-   [Application layout guide](https://shiny.rstudio.com/articles/layout-guide.html)\n\n### Shiny Module\n\n-   [Chapter 19 Shiny modules](https://mastering-shiny.org/scaling-modules.html) of Mastering Shiny.\n-   [Modularizing Shiny app code](https://shiny.rstudio.com/articles/modules.html), online article\n-   [Communication between modules](https://shiny.rstudio.com/articles/communicate-bet-modules.html). This is a relatively old article, some functions have changed.\n-   [Shiny Modules](https://www.inwt-statistics.com/read-blog/shiny-modules.html)\n-   [Shiny Modules (part 1) : Why using modules?](https://www.ardata.fr/en/post/2019/02/11/why-using-modules/)\n-   [Shiny Modules (part 2): Share reactive among multiple modules](https://www.ardata.fr/en/post/2019/04/26/share-reactive-among-shiny-modules/)\n-   [Shiny Modules (part 3): Dynamic module call](https://www.ardata.fr/en/post/2019/07/01/dynamic-module-call/)\n\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}